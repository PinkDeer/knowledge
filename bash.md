[Atom](/atom.md) [Bash](bash.md) [Gems](/gems.md) [Github](/github.md) [HTML](html.md) [jQuery](/jquery.md) [Linux](/linux.md) [Rails](rails.md) [Ruby](ruby.md) [SQL](sql.md) [SSH](ssh.md) [Tasks](tasks.md)

## Bash


* [cd](#cd)
* [ls](#ls)
* [mkdir](#mkdir)
* [touch](#touch)
* [echo](#echo)
* [cat и cp](#cat-и-cp)
* [mv](#mv)
* [links](#links)
* [rm/rmdir](#rmrmdir)
* [wildcards](#wildcards)
* [kill](#kill)
* [wget](#wget)

> Большинство команд Linux могут быть запущены с параметром  "--help"
>
> Более расширенная информация доступна из командной строки с использованием так называемых страниц руководства ("manual pages" или манов) - "man <command>"
>
> Список встроенных командах bash может быть получен вводом команды  help. А помощь по любой встроенной команде можно получить, набрав, например, так: help cd
>
> [Подробней](https://www.sao.ru/hq/sts/linux/doc/lnag/2.html)


### cd

---

#### Перейти в корневую директорию
```
\$ cd /
```
#### Перейти к домашнюю директорию

```
$ cd
```
Без аргумента cd переместит вас в домашнюю директорию. Для суперпользователя домашней обычно является директория /root, а для обычных пользователей — /home/username/.

~ — специальное имя, указывающее в bash на домашнюю директорию пользователя.

#### Текущаю рабочая директория
```
$ pwd
```
#### Абсолютный путь

Абсолютный путь всегда начинается с /.

```
/dev
/usr
/usr/bin
/usr/local/bin
```
#### Отноcительный путь

Путь отноcительно текущей директории (pwd).
```
\$ cd local/bin
\$ pwd
/usr/local/binn
```
```
/home/user/file.txt
or
~/file.txt
```
[Пример](http://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/)

#### Использование ".."

Относительные пути могут содержать одну или несколько директорий "..". ".." указывает на родительскую директорию по отношению к нашей рабочей директории

```
\$ pwd
/usr/local/bin
\$ cd ..
\$ pwd
/usr/local
```
Можно добавить .. к относительному пути. Это позволит переместиться в директорию, которая находится на одном уровне с той в которой мы находимся

```
\$ pwd
/usr/local
\$ cd ../share
\$ pwd
/usr/share
```
[![up](/image/up.png)](#bash)

#### Рабочая директория "."

Специальная директория "." указывающаю на текущую директорию.
```
\$ ./script.sh
```
[![up](/image/up.png)](#bash)

####  Домашние директории других пользователей

Но что если нам нужно указать файл в домашней директории другого пользователя? Для этого после тильды нужно указать имя этого пользователя. Например, чтобы указать на файл fredsfile.txt находящийся в домашней директории пользователя fred:

```
\$ ./myprog ~fred/fredsfile.txt
```


### ls

---

([en](https://en.wikipedia.org/wiki/Ls)|[rus](http://rus-linux.net/MyLDP/consol/hdrguide/rusman/ls.htm))


ls без аргументов, выводит на экран список файлов хранящихся в рабочей директории:

```l
\$ ls
```

[![up](/image/up.png)](#bash)



### mkdir

---

([en](https://en.wikipedia.org/wiki/Mkdir)|[rus](https://ru.wikipedia.org/wiki/Mkdir))

```
$ mkdir folder
```
Создание вложенной структуры директорий
```
$ mkdir -p folder/folder2/folder3
```
[![up](/image/up.png)](#bash)



### touch

---

([en](https://en.wikipedia.org/wiki/Touch_%28Unix%29)|[rus](http://itcollider.ru/forum/linuxoid/1181-komanda-touch-v-linux.html))

Команда touch обновляет время последнего доступа к файлу если он уже существует или создает новый пустой файл, если его ещё нету.

```
\$ touch filename
```


[![up](/image/up.png)](#bash)



### echo

---

([en](http://linux.die.net/man/1/echo)|[rus](https://ru.wikipedia.org/wiki/Echo)|[habr](https://habrahabr.ru/post/119436/))

echo - команда, предназначенная для отображения строки текста
```
\$ echo "firstfile"
```
Может служить для записи строки в файл, если используется > файл будет перезаписан, если >> строка будет дописана в конец файла.
```
\$ echo "firstfile" > filename
```

[![up](/image/up.png)](#bash)


### cat и cp

---

([en](http://linux.die.net/man/1/cat)|[rus](http://rus-linux.net/lib.php?name=/MyLDP/consol/HuMan/cat-ru.html))

Для вывода содержимого файла на терминал используется команда cat:
```
\$ cat copyme
firstfile
```
([en](http://linux.die.net/man/1/cp)|[rus](https://ru.wikipedia.org/wiki/Cp))

Теперь мы можем приступить к разбору базовой функциональности команды cp. Эта команда принимает два аргумента. Первый — имя уже существующего файла ('copyme'), второй — название новой копии, которую мы хотим сделать ('copiedme').
```
\$ cp copyme copiedme
```
Можем убедиться, что новая копия файла имеет другой номер инода (это значит что мы получили действительно новый отдельный файл, а не просто ссылку на старый)
```
\$ ls -i copyme copiedme
  648284 copiedme   650704 copyme
```

[![up](/image/up.png)](#bash)


### mv

---

([en](http://linux.die.net/man/1/mv)|[rus](https://ru.wikipedia.org/wiki/Mv))


Теперь применим команду mv чтобы переименовать файл ("copiedme" –> "movedme"). Номер инода после этой операции не меняется, а изменяется только название файла.
```
\$ mv copiedme movedme
\$ ls -i movedme
  648284 movedme
```
Номер инода не изменяется только при условии, что переименованный файл остается в пределах той файловой системы где находился исходный файл. Мы рассмотрим подробнее устройство файловых систем в одной из следующих частей этого пособия.
Команда mv позволяет не только переименовывать файлы, но и перемещать их. Например, чтобы переместить файл /var/tmp/myfile.txt в директорию /home/user нужно дать команду:
```
\$ mv /var/tmp/myfile.txt /home/user
```
Файл будет перемещен в домашнюю директорию пользователя user даже если она находится в другой файловой системе (в этом случае файл будет скопирован в новое место после чего оригинал будет удален). Как вы могли уже догадаться, перемещение файла в другую файловую систему приводит к изменению его инода. Это происходит потому, что каждая файловая система имеет свой отдельный набор инодов.

> Нужно заметить, существует вероятность, что новый присвоенный номер инода может совпасть со старым, но она чрезвычайно мала.

Чтобы переместить одновременно несколько файлов в одну директорию нужно написать:
```
\$ mv /var/tmp/myfile1.txt /var/tmp/myfile2.txt /home/user
```
или
```
\$ mv -t /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
```
Если добавить опцию '-v', на экран будет выведен отчет о проделанной операции:
```
\$ mv -vt /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
   '/var/tmp/myfile1.txt' -> '/home/user/myfile1.txt'
   '/var/tmp/myfile2.txt' -> '/home/user/myfile2.txt'
```

[![up](/image/up.png)](#bash)


### links

---

([rus](https://docs.altlinux.org/ru-RU/archive/2.4/html-single/master/alt-docs-extras-linuxcovice/ch02s09.html)|[habr](https://habrahabr.ru/post/99746/))

#### Жесткие ссылки

 Каждый инод может иметь несколько связанных с ним жестких ссылок. Таким образом, получается что файл присутствует в системе под несколькими разными именами. Файл существует до тех пор, пока с его инодом связано хотя бы одно имя. Понятия «жёсткая ссылка на файл» и «имя файла» являются синонимами. Новые жесткие ссылки на файл можно сделать при помощи команды ln
```
\$ cd /tmp
\$ touch firstlink
\$ ln firstlink secondlink
\$ ls -i firstlink secondlink
  15782 firstlink    15782 secondlink
```
Как видно из примера, жесткие ссылки работают на уровне инодов, указывая на определенный файл. В линуксе у жестких ссылок есть несколько ограничений. Во-первых, вы можете создавать жесткие ссылки только на файлы, но не на директории. Вот именно, несмотря на то что в системе существуют жесткие ссылки на директории ('.' и '..'), даже суперпользователь не может создавать дополнительные жесткие ссылки на директории. Во-вторых, невозможно создать жесткую ссылку на файл находящийся в другой файловой системе, т.к. каждая файловая система имеет свой уникальный набор инодов.

#### Символические ссылки

На практика чаще применяют символические ссылки (или симлинки). Симлинк это специальный вид файла, который ссылается на другой файл по имени, а не напрямую на инод. Симлинки не предохраняют файл от удаления. Если файл удалить, то симлинк на него станет нерабочим (или битым).

Симлинки создаются командой ln с опцией '-s':
```
\$ ln -s secondlink thirdlink
\$ ls -l firstlink secondlink thirdlink
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 firstlink
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 secondlink
lrwxrwxrwx    1 agriffis agriffis       10 Dec 31 19:39 thirdlink -> secondlink
```
Символическую ссылку можно распознать по выводу команды ls -l: во-первых, в первой колонке у симлинков стоит буква 'l' (первая буква английского слова link–ссылка), во-вторых, размер симлинка равен количеству букв в имени файла на который он ссылается ('secondlink' в нашем случае), в-третьих, последняя колонка помимо имени ссылки содержит имя файла на который она ссылается после знака –>

#### Подробнее о симлинках

Символические ссылки намного гибче жестких. С их помощью вы можете ссылаться на любой объект (файл, директория, сокет...) любой файловой системы.

Рассмотрим ситуацию, когда мы хотим сделать симлинк который указывает на /usr/local/bin и находится в директории /tmp/. Мы можем написать:
```
\$ ln -s /usr/local/bin bin1
\$ ls -l bin1
lrwxrwxrwx    1 root     root           14 Jan  1 15:42 bin1 -> /usr/local/bin
```
Или
```
\$ ln -s ../usr/local/bin bin2
\$ ls -l bin2
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin
```
Как видно из этих примеров, обе ссылки указывают на одну директорию. Но, если вторую ссылку переместить из /tmp в другую директорию, она может оказаться битой из-за использованного в ней относительного пути.
```
\$ ls -l bin2
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin
\$ mkdir mynewdir
\$ mv bin2 mynewdir
\$ cd mynewdir
\$ cd bin2
bash: cd: bin2: No such file or directory
```
Так как не существует директории /tmp/usr/local/bin/, мы не сможем сменить рабочую директорию на bin2; другими словами, после перемещения ссылка перестала работать (стала 'битой').

По этой причине, иногда стоит избегать создания симлинков, используя относительные пути. Но иногда это бывает удобно. Рассмотрим такой случай: допустим мы хотим сделать ссылку на программу в /usr/bin (или другими словами присвоить этой программе альтернативное имя):
```
# ls -l /usr/bin/keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
```
Суперпользователь (root) может захотеть сделать ссылку на программу "keychain" с более коротким именем "kc". В этом примере у нас есть рутовый доступ к системе, о чем свидетельствует приглашение bash, изменившееся на "#". Нам нужны права суперпользователя потому, что обычные пользователи не могут создавать файлы в директории /usr/bin/. Теперь мы можем от имени рута создать альтернативное имя для нашей программы:
```
# cd /usr/bin
# ln -s /usr/bin/keychain kc
# ls -l keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
# ls -l kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain
```
В этом примере мы создали симлинк kc ссылающийся на файл /usr/bin/keychain.

Эта ссылка полностью рабочая, но она перестанет работать, если мы решим перенести оба файла 'keychain' и 'kc' из директории /usr/bin/ в /usr/local/bin/:
```
# mv /usr/bin/keychain /usr/bin/kc /usr/local/bin
# ls -l /usr/local/bin/keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# ls -l /usr/local/bin/kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain
```
Из-за того что мы использовали абсолютный путь при создании ссылки, она продолжает указывать на файл /usr/bin/keychain, которого больше нет. Но если бы мы использовали относительный путь при создании ссылки, она бы осталась рабочей.

Можно сделать вывод, что ссылки созданные с абсолютными и относительными путями имеют каждая свое применение. Поэтому при создании симлинка нужно выбрать способ, который будет уместнее в данной конкретной ситуации.

Часто оба вида симлинков (с абсолютными и относительным и путями) работают нормально. Следующий пример показывает способ создания симлинка, который продолжает работать после перемещения его и файла на который он ссылается в другую директорию:
```
# cd /usr/bin
# ln -s keychain kc
# ls -l kc
lrwxrwxrwx    1 root     root            8 Jan  5 12:40 kc -> keychain
# mv keychain kc /usr/local/bin
# ls -l /usr/local/bin/keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# ls -l /usr/local/bin/kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> keychain
```
Теперь мы можем запускать программу 'keychain', обратившись к ней по имени /usr/local/bin/kc


[![up](/image/up.png)](#bash)

### rm/rmdir

---

#### Удаление файла

```
\$ cd /tmp
\$ touch file1 file2
\$ ls -l file1 file2
-rw-r--r--    1 root     root            0 Jan  1 16:41 file1
-rw-r--r--    1 root     root            0 Jan  1 16:41 file2
\$ rm file1 file2
\$ ls -l file1 file2
ls: file1: No such file or directory
ls: file2: No such file or directory
```
Удалить файл с подтверждением
```
\$ rm -i file1 file2
rm: remove regular empty file `file1'? y
rm: remove regular empty file `file2'? y
```

Рекурсивное удаление всех файлов, каталогов, подкаталогов, и т.д., не запрашивая явного подтверждения для каждого стирания:
```
rm -rf folder/folder2/
```

Прервать выполнение любой команды можно нажав комбинацию Ctrl–C.

Удаление с запросом по умолчанию: добавить строку в ~/.bashrc

```
alias rm="rm -i"
```

#### Удадение папки
```
rm -rf mydir
```

[![up](/image/up.png)](#bash)


### wildcards

---
#### Что такое wildcards

При повседневном использовании линукса часто возникают ситуации когда нужно выполнить одну простую операцию (например rm) над множеством файлов. В этом случае не очень то удобно перечислять все имена файлов в командной строке:
```
\$ rm file1 file2 file3 file4 file5 file6 file7 file8
```
Решить эту проблему можно при помощи шаблонов замены (wildcards). Командный интерпретатор линукс поддерживает возможность указания множества файлов используя шаблоны (по историческим причинам это еще называют "globbing"). Bash и другие команды линукс выбирают только те файлы, которые совпадают с шаблоном. Так, если вам нужно удалить файлы с file1 по file8, нужно написать:
```
\$ rm file[1-8]
```
А если нужно удалить все файлы имена которых начинаются со слова file и файл с именем file:
```
\$ rm file*
```
Шаблон * соответствует любому символу, последовательности символов или "отсутствию символа". Конечно, шаблоны можно применять не только для удаления файлов, как будет показано ниже.

#### Если совпадение не найдено

Если вы хотите вывести список файлов в директории /etc/ имена которых начинаются с буквы "g" и файл с именем "g" (если такой существует), нужно написать:
```
\$ ls -d /etc/g*
/etc/gconf  /etc/ggi  /etc/gimp  /etc/gnome  /etc/gnome-vfs-mime-magic  /etc/gpm  /etc/group  /etc/group-
```
Посмотрим что случится если вы укажете шаблон который не совпадает ни с одним именем файла:
```
\$ ls -d /usr/bin/asdf*jkl
ls: /usr/bin/asdf*jkl: No such file or directory
```
В этом примере мы попытались вывести список файлов имена которых начинаются на "asdf" и заканчиваются на "jkl". Интерпретатор команд выдал сообщение что файлов с такими именами не найдено.

#### Синтаксис шаблона: * и ?

Мы посмотрели как работает глоббинг (подстановка имен файлов). А теперь рассмотрим подробнее синтаксис шаблонов:

* соответствует нулю или большему количеству символов:

* /etc/g* — все файлы в директории /etc/ имена которых начинаются с "g" и файл с именем "g".
* /tmp/my*1 — все файлы в директории /tmp имена которых начинаются с "my" и заканчиваются на "1" (включая файл с именем "my1")

? заменяет один любой символ:

* myfile? — любой файл чье имя начинается со слова "myfile" за которым следует один любой символ.
* /tmp/notes?txt — соответствует файлам с именами "notes.txt" и "notes_txt" (если они существуют в /tmp/).

#### Квадратные скобки: []

Шаблон '[]' очень похож на '?' но позволяет явно указывать набор символов. Шаблон '[]' совпадает с одним символом из тех что указаны в скобках. Также в скобках можно указать диапазон символов (для этого используется символ –/дефис) или несколько диапазонов подряд, тогда шаблон будет совпадать с одним любым символом из этого диапазона:

* myfile[12] — соответствует myfile1 и myfile2. Шаблон будет работать пока существует хотя бы один из этих двух файлов.
* [Cc]hange[Ll]og — соответствует файлам с и* менами Changelog, ChangeLog, changeLog, и changelog. Как вы могли заметить, использование шаблона [] полезно при поиске имен отличающихся регистром букв.*
* ls /etc/[0-9]* — вывести список файлов в директории /etc/ имена которых начинаются с цифры.
* ls /tmp/[A-Za-z]* — вывести список файлов в директории /tmp/ имена которых начинаются с буквы (заглавной или прописной)

Конструкция [[] похожа на [], за исключением того что она соответствует единичному символу, не упомянутому между [[ и ]. Например:

* rm myfile[[9] — удалит все файлы, имена которых состоят из слова "myfile" и идущей за ним одной цифрой, кроме файла "myfile9".

#### Примеры использования

Вот несколько примеров использования шаблонов. Так как bash интерпретирует символы ?, [, ], * как шаблоны замены, необходимо принять меры предосторожности при использовании аргументов содержащих эти символы. Например, если вы хотите создать файл содержащий строку '[fo]*', то следующая команда сделает не то что вы хотите:
```
\$ echo [fo]* > /tmp/mynewfile.txt
```
Если в вашей рабочей директории найдется один или несколько файлов, имена которых попадают под шаблон '[fo]*', то вы обнаружите в /tmp/mynewfile.txt список их имен, а не строку '[fo]*'. Но как же добиться того чего мы хотели? Первый способ — это взять строку в одинарные кавычки. К строке в одинарных кавычках bash относится как к обычной текстовой строке и не раскрывает символы замены.
```
\$ echo '[fo]*' > /tmp/mynewfile.txt
```
После выполнения этой команды ваш файл будет содержать строку '[fo]*' как и ожидалось. Другой способ — заэкранировать спец.символы с помощью обратного слэша (\). Бэкслэш стоящий перед спец.символом сообщает интерпретатору, что этот символ нужно рассматривать как обычный текст а не как шаблон.
```
\$ echo \[fo\]\* > /tmp/mynewfile.txt
```
Оба предложенных метода (одинарные кавычки и экранирование) дают желаемый результат. Раз уж мы заговорили об экранировании при помощи обратного слэша, стоит сказать, что чтобы указать текстовый символ "\" можно заключить его в одинарные кавычки или написать "\\\" (эта комбинация будет воспринята интерпретатором как обычный одинарный бэкслэш "\")

> Замечание: Двойные кавычки работаю почти так же как и одинарные, но позволяют bash-у интерпретировать некоторые спец.символы. Поэтому одинарные кавычки — лучший способ передать команде только текст. Для дополнительной информации о шаблонах читайте справку 'man 7 glob'. Для дополнительной информации об использовании кавычек, читайте раздел QUOTING справки 'man 8 glob'.

[![up](/image/up.png)](#bash)


### kill

---

([en](http://linux.die.net/man/1/killall)|[rus](http://rus-linux.net/MyLDP/BOOKS/MDK-10/process-signals.html)|[rus2](http://rus-linux.net/MyLDP/consol/kill.html)|[habr](https://habrahabr.ru/post/95102/))

killall - принудительное завершение программы
```
killall firefox
```
или
```
admin@pingvinus:~$ ps -Aef | grep firefox
admin     2275     1 11 07:42 ?        00:05:52 /usr/lib/firefox-3.5.8/firefox
admin     2821  2800  0 08:32 pts/2    00:00:00 grep firefox
admin@pingvinus:~$ kill 2275
```
[![up](/image/up.png)](#bash)


### wget

---

[rus](http://help.ubuntu.ru/wiki/wget)

wget - программа для скачивная файлов


Если возникает проблема  сертифинатом, то использовать опцию
```
wget  --no-check-certificate https://randomsite.ru
```

[![up](/image/up.png)](#bash)
