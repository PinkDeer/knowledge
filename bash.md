## Bash


* [cd](#cd)
* [ls](#ls)
* [mkdir](#mkdir)
* [touch](#touch)
* [echo](#echo)
* [cat и cp](#cat-и-cp)
* [mv](#mv)
* [links](#cat-и-cp)
* [rm/rmdir](#rm/rmdir)
* [kill](#kill)

> Большинство команд Linux могут быть запущены с параметром  "--help"
>
> Более расширенная информация доступна из командной строки с использованием так называемых страниц руководства ("manual pages" или манов) - "man <command>"
>
> Список встроенных командах bash может быть получен вводом команды  help. А помощь по любой встроенной команде можно получить, набрав, например, так: help cd
>
> [Подробней](https://www.sao.ru/hq/sts/linux/doc/lnag/2.html)


### cd

---

#### Перейти в корневую директорию
```
\$ cd /
```
#### Перейти к домашнюю директорию

```
$ cd
```
Без аргумента cd переместит вас в домашнюю директорию. Для суперпользователя домашней обычно является директория /root, а для обычных пользователей — /home/username/.

~ — специальное имя, указывающее в bash на домашнюю директорию пользователя.

#### Текущаю рабочая директория
```
$ pwd
```
#### Абсолютный путь

Абсолютный путь всегда начинается с /.

```
/dev
/usr
/usr/bin
/usr/local/bin
```
#### Отноcительный путь

Путь отноcительно текущей директории (pwd).
```
\$ cd local/bin
\$ pwd
/usr/local/binn
```
```
/home/user/file.txt
or
~/file.txt
```
[Пример](http://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/)

#### Использование ".."

Относительные пути могут содержать одну или несколько директорий "..". ".." указывает на родительскую директорию по отношению к нашей рабочей директории

```
\$ pwd
/usr/local/bin
\$ cd ..
\$ pwd
/usr/local
```
Можно добавить .. к относительному пути. Это позволит переместиться в директорию, которая находится на одном уровне с той в которой мы находимся

```
\$ pwd
/usr/local
\$ cd ../share
\$ pwd
/usr/share
```
[![up](/image/up.png)](#bash)

#### Рабочая директория "."

Специальная директория "." указывающаю на текущую директорию.
```
\$ ./script.sh
```
[![up](/image/up.png)](#bash)

####  Домашние директории других пользователей

Но что если нам нужно указать файл в домашней директории другого пользователя? Для этого после тильды нужно указать имя этого пользователя. Например, чтобы указать на файл fredsfile.txt находящийся в домашней директории пользователя fred:

```
\$ ./myprog ~fred/fredsfile.txt
```


### ls

---

([en](https://en.wikipedia.org/wiki/Ls)|[rus](http://rus-linux.net/MyLDP/consol/hdrguide/rusman/ls.htm))


ls без аргументов, выводит на экран список файлов хранящихся в рабочей директории:

```l
\$ ls
```

[![up](/image/up.png)](#bash)



### mkdir

---

([en](https://en.wikipedia.org/wiki/Mkdir)|[rus](https://ru.wikipedia.org/wiki/Mkdir))

```
$ mkdir folder
```
Создание вложенной структуры директорий
```
$ mkdir -p folder/folder2/folder3
```
[![up](/image/up.png)](#bash)



### touch

---

([en](https://en.wikipedia.org/wiki/Touch_%28Unix%29)|[rus](http://itcollider.ru/forum/linuxoid/1181-komanda-touch-v-linux.html))

Команда touch обновляет время последнего доступа к файлу если он уже существует или создает новый пустой файл, если его ещё нету.

```
\$ touch filename
```


[![up](/image/up.png)](#bash)



### echo

---

([en](http://linux.die.net/man/1/echo)|[rus](https://ru.wikipedia.org/wiki/Echo)|[habr](https://habrahabr.ru/post/119436/))

echo - команда, предназначенная для отображения строки текста
```
\$ echo "firstfile"
```
Может служить для записи строки в файл, если используется > файл будет перезаписан, если >> строка будет дописана в конец файла.
```
\$ echo "firstfile" > filename
```

[![up](/image/up.png)](#bash)


### cat и cp

---

([en](http://linux.die.net/man/1/cat)|[rus](http://rus-linux.net/lib.php?name=/MyLDP/consol/HuMan/cat-ru.html))

Для вывода содержимого файла на терминал используется команда cat:
```
\$ cat copyme
firstfile
```
([en](http://linux.die.net/man/1/cp)|[rus](https://ru.wikipedia.org/wiki/Cp))

Теперь мы можем приступить к разбору базовой функциональности команды cp. Эта команда принимает два аргумента. Первый — имя уже существующего файла ('copyme'), второй — название новой копии, которую мы хотим сделать ('copiedme').
```
\$ cp copyme copiedme
```
Можем убедиться, что новая копия файла имеет другой номер инода (это значит что мы получили действительно новый отдельный файл, а не просто ссылку на старый)
```
\$ ls -i copyme copiedme
  648284 copiedme   650704 copyme
```

[![up](/image/up.png)](#bash)


### mv

---

([en](http://linux.die.net/man/1/mv)|[rus](https://ru.wikipedia.org/wiki/Mv))


Теперь применим команду mv чтобы переименовать файл ("copiedme" –> "movedme"). Номер инода после этой операции не меняется, а изменяется только название файла.
```
\$ mv copiedme movedme
\$ ls -i movedme
  648284 movedme
```
Номер инода не изменяется только при условии, что переименованный файл остается в пределах той файловой системы где находился исходный файл. Мы рассмотрим подробнее устройство файловых систем в одной из следующих частей этого пособия.
Команда mv позволяет не только переименовывать файлы, но и перемещать их. Например, чтобы переместить файл /var/tmp/myfile.txt в директорию /home/user нужно дать команду:
```
\$ mv /var/tmp/myfile.txt /home/user
```
Файл будет перемещен в домашнюю директорию пользователя user даже если она находится в другой файловой системе (в этом случае файл будет скопирован в новое место после чего оригинал будет удален). Как вы могли уже догадаться, перемещение файла в другую файловую систему приводит к изменению его инода. Это происходит потому, что каждая файловая система имеет свой отдельный набор инодов.

> Нужно заметить, существует вероятность, что новый присвоенный номер инода может совпасть со старым, но она чрезвычайно мала.

Чтобы переместить одновременно несколько файлов в одну директорию нужно написать:
```
\$ mv /var/tmp/myfile1.txt /var/tmp/myfile2.txt /home/user
```
или
```
\$ mv -t /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
```
Если добавить опцию '-v', на экран будет выведен отчет о проделанной операции:
```
\$ mv -vt /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
   '/var/tmp/myfile1.txt' -> '/home/user/myfile1.txt'
   '/var/tmp/myfile2.txt' -> '/home/user/myfile2.txt'
```

[![up](/image/up.png)](#bash)


### links

---

([rus](https://docs.altlinux.org/ru-RU/archive/2.4/html-single/master/alt-docs-extras-linuxcovice/ch02s09.html)|[habr](https://habrahabr.ru/post/99746/))

#### Жесткие ссылки

 Каждый инод может иметь несколько связанных с ним жестких ссылок. Таким образом, получается что файл присутствует в системе под несколькими разными именами. Файл существует до тех пор, пока с его инодом связано хотя бы одно имя. Понятия «жёсткая ссылка на файл» и «имя файла» являются синонимами. Новые жесткие ссылки на файл можно сделать при помощи команды ln
```
\$ cd /tmp
\$ touch firstlink
\$ ln firstlink secondlink
\$ ls -i firstlink secondlink
  15782 firstlink    15782 secondlink
```
Как видно из примера, жесткие ссылки работают на уровне инодов, указывая на определенный файл. В линуксе у жестких ссылок есть несколько ограничений. Во-первых, вы можете создавать жесткие ссылки только на файлы, но не на директории. Вот именно, несмотря на то что в системе существуют жесткие ссылки на директории ('.' и '..'), даже суперпользователь не может создавать дополнительные жесткие ссылки на директории. Во-вторых, невозможно создать жесткую ссылку на файл находящийся в другой файловой системе, т.к. каждая файловая система имеет свой уникальный набор инодов.

#### Символические ссылки

На практика чаще применяют символические ссылки (или симлинки). Симлинк это специальный вид файла, который ссылается на другой файл по имени, а не напрямую на инод. Симлинки не предохраняют файл от удаления. Если файл удалить, то симлинк на него станет нерабочим (или битым).

Симлинки создаются командой ln с опцией '-s':
```
\$ ln -s secondlink thirdlink
\$ ls -l firstlink secondlink thirdlink
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 firstlink
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 secondlink
lrwxrwxrwx    1 agriffis agriffis       10 Dec 31 19:39 thirdlink -> secondlink
```
Символическую ссылку можно распознать по выводу команды ls -l: во-первых, в первой колонке у симлинков стоит буква 'l' (первая буква английского слова link–ссылка), во-вторых, размер симлинка равен количеству букв в имени файла на который он ссылается ('secondlink' в нашем случае), в-третьих, последняя колонка помимо имени ссылки содержит имя файла на который она ссылается после знака –>

#### Подробнее о симлинках

Символические ссылки намного гибче жестких. С их помощью вы можете ссылаться на любой объект (файл, директория, сокет...) любой файловой системы.

Рассмотрим ситуацию, когда мы хотим сделать симлинк который указывает на /usr/local/bin и находится в директории /tmp/. Мы можем написать:
```
\$ ln -s /usr/local/bin bin1
\$ ls -l bin1
lrwxrwxrwx    1 root     root           14 Jan  1 15:42 bin1 -> /usr/local/bin
```
Или
```
\$ ln -s ../usr/local/bin bin2
\$ ls -l bin2
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin
```
Как видно из этих примеров, обе ссылки указывают на одну директорию. Но, если вторую ссылку переместить из /tmp в другую директорию, она может оказаться битой из-за использованного в ней относительного пути.
```
\$ ls -l bin2
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin
\$ mkdir mynewdir
\$ mv bin2 mynewdir
\$ cd mynewdir
\$ cd bin2
bash: cd: bin2: No such file or directory
```
Так как не существует директории /tmp/usr/local/bin/, мы не сможем сменить рабочую директорию на bin2; другими словами, после перемещения ссылка перестала работать (стала 'битой').

По этой причине, иногда стоит избегать создания симлинков, используя относительные пути. Но иногда это бывает удобно. Рассмотрим такой случай: допустим мы хотим сделать ссылку на программу в /usr/bin (или другими словами присвоить этой программе альтернативное имя):
```
# ls -l /usr/bin/keychain 
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
```
Суперпользователь (root) может захотеть сделать ссылку на программу "keychain" с более коротким именем "kc". В этом примере у нас есть рутовый доступ к системе, о чем свидетельствует приглашение bash, изменившееся на "#". Нам нужны права суперпользователя потому, что обычные пользователи не могут создавать файлы в директории /usr/bin/. Теперь мы можем от имени рута создать альтернативное имя для нашей программы:
```
# cd /usr/bin
# ln -s /usr/bin/keychain kc
# ls -l keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
# ls -l kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain
```
В этом примере мы создали симлинк kc ссылающийся на файл /usr/bin/keychain.

Эта ссылка полностью рабочая, но она перестанет работать, если мы решим перенести оба файла 'keychain' и 'kc' из директории /usr/bin/ в /usr/local/bin/:
```
# mv /usr/bin/keychain /usr/bin/kc /usr/local/bin
# ls -l /usr/local/bin/keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# ls -l /usr/local/bin/kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain
```
Из-за того что мы использовали абсолютный путь при создании ссылки, она продолжает указывать на файл /usr/bin/keychain, которого больше нет. Но если бы мы использовали относительный путь при создании ссылки, она бы осталась рабочей.

Можно сделать вывод, что ссылки созданные с абсолютными и относительными путями имеют каждая свое применение. Поэтому при создании симлинка нужно выбрать способ, который будет уместнее в данной конкретной ситуации.

Часто оба вида симлинков (с абсолютными и относительным и путями) работают нормально. Следующий пример показывает способ создания симлинка, который продолжает работать после перемещения его и файла на который он ссылается в другую директорию:
```
# cd /usr/bin
# ln -s keychain kc
# ls -l kc
lrwxrwxrwx    1 root     root            8 Jan  5 12:40 kc -> keychain
# mv keychain kc /usr/local/bin
# ls -l /usr/local/bin/keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# ls -l /usr/local/bin/kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> keychain
```
Теперь мы можем запускать программу 'keychain', обратившись к ней по имени /usr/local/bin/kc


[![up](/image/up.png)](#bash)


### rm

---

#### Удаление файла

```
\$ cd /tmp
\$ touch file1 file2
\$ ls -l file1 file2
-rw-r--r--    1 root     root            0 Jan  1 16:41 file1
-rw-r--r--    1 root     root            0 Jan  1 16:41 file2
\$ rm file1 file2
\$ ls -l file1 file2
ls: file1: No such file or directory
ls: file2: No such file or directory
```
Удалить файл с подтверждением
```
\$ rm -i file1 file2
rm: remove regular empty file `file1'? y
rm: remove regular empty file `file2'? y
```

Прервать выполнение любой команды можно нажав комбинацию Ctrl–C.

Удаление с запросом по умолчанию: добавить строку в ~/.bashrc

```
alias rm="rm -i"
```

#### Удадение папки
```
rm -rf mydir
```


[![up](/image/up.png)](#bash)



### kill

---

([en](http://linux.die.net/man/1/killall)|[rus](http://rus-linux.net/MyLDP/BOOKS/MDK-10/process-signals.html)|[rus2](http://rus-linux.net/MyLDP/consol/kill.html)|[habr](https://habrahabr.ru/post/95102/))

killall - принудительное завершение программы
```
killall firefox
```
или
```
admin@pingvinus:~$ ps -Aef | grep firefox
admin     2275     1 11 07:42 ?        00:05:52 /usr/lib/firefox-3.5.8/firefox
admin     2821  2800  0 08:32 pts/2    00:00:00 grep firefox
admin@pingvinus:~$ kill 2275
```
[![up](/image/up.png)](#bash)
