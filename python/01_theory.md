### Операторы

| Оператор | Описание |
| ------ | ----------- |
| +   | Сложение |
| - | Вычитание |
| * | Умножение |
| /    | Деление (в результате вещественное число) |
| //    | Деление с округлением вниз |
| **    | Возведение в степень |
| %    | Остаток от деления |

### Функции

help() - вызов документации для функии

[Встроенные функции RU](https://pythoner.name/documentation/library/functions)

Собственные функции
```
def func_name(var): # объявление функции, название, параметр(ы)
  return var * 2    # возвращение резуьтата функции

>>> func_name(4)    # вызов функции с аргументом
8                   # результат вычислений
```
В python имени функции можно присвоить другое имя (изменить адрес на объект)
```
def sum(x,y):
    return x + y
n = sum
print(n(2,3))

```
Параметры фукнкций могут принримать значения по умолчанию
```
def sum(x,y=4):
    return x + y
a = sum(2)
b = sum(2, 5)
```
Так же можно передавать значения конкретным параметрам
```
def sum(a, b=3, c=7):
    return a + b + c

print(sum(2,4))
print(sum(2,c = 4))
print(sum(b=1,c=4)) # ошибка
```
Имя функции можно передать в качестве аргумента другой функции, т.к. это тоже переменная
```
def sum(x,y):
    return x + y

def func(f, a, b):
    return f(a, b)

n = func(sum, 10, 3)
print(n)
```
#### Области видимости переменных

Если значение переменной присвоено внутри функции, то она локальная и её видно только внутри фукнции, в другом случае перменная глобальная и её видно во всей программе.
```
x = 1 # глобальная переменная
y = 3 # глобальная переменная
def func():
    print(x)
    y = 5  # локальная переменная
    print(y)
func()
print(y)
```
```
1
5
3
```

Чтобы изменить содержимое глобальной переменной внутри функции, необхоимо использовать ключевое слово _global_
```
x = 2  # глобальная переменная
def func():
    global x # указываем, что x глобальная переменная
    print(x)
    x = 1 # переопределяем глобальную переменную
    print(x)
func()
print(x)
```
```
2
1
1
```

#### Подробнее

int() - возвращает целое число в десятичной системе счисления
```
int(2.3)
2
```
float(x) - возвращает число с плавающей точкой, созданное из числа или строки x
```
float(3)
3.0
```

Абсолютное число для объекта
```
>>> abs(-2)
2
```
```
>>> a = abs(-3) + abs(-2)
5
```
Возврат значения x в степени y
```
pow(x, y)
```
Округление числа с плавающей точкой
```
round(2,4221) # по умолчанию до 0 цифр после запятой
2
```
```
round(2,4221, 2) # указываем число знаков после запятой
2.42
```
В качеcтве аргументов для функции можно передавать результат вызовы других функий
```
float(round(pow(round(2.4323, 2), 2)))
6
```

### Строки

Преобразование в строковый тип данных
```
str(4)
```
#### Полезные функции

_print_ имеет несколько аргументов
```
help(print)
```
Функция input возварщает строковый объект
```
>>> s = input()  
hello
>>> s   
'hello'
>>> type(s)   
<class 'str'>
>>>
```
Обратиться по индексу
```
>>> s = "Tra ta ta"
>>> s[0]
T
>>> s[-1]
a
```
Положительный аналог [-1]
```
>>> print(len(s)-1)
8
>>> s[len(s)-1]
a
```
#### Срезы

```
>>> s = "Hello World"
>>> s[1:3] # срех начинается с индекса 1, заканчаивается индексом 3 (не включительно)
'el'
>>> s[:3] # с 0 индекса по 3-ий не включительно
'Hel'
>>> s[:] с 0 индекса по 3-ий не включительно
'Hello World'
>>> s[::2] # третий аргумент задает шаг (по умолчанию один)
'HloWrd'
>>> s[::-1] # «обратный» шаг
'dlroW olleH'
>>> s[:-1] # отрицательный индекс
'Hello Worl'
>>> s[-1:] # отрицательный индекс
'd'

```

#### Escape-последовательности

| Синтаксис | Описание |
| ------ | ----------- |
| \n | Переход на новую строку |
| \t | Знак табуляции |
| \\ | Наклонная черта влево |
| \' | Символ одиночной кавычки |
| \"  | Символ двойной кавычки |

Для ковычек можно использовать разные виды ковычек
```
print("Let`s")
```
Для переноса строки можно использовать тройные кавычки
```
print('''New
Line)
```
### Операторы отношений

| Синтаксис | Описание |
| ------ | ----------- |
| >  | Больше |
| < | Меньше |
| >= | Больше или равно |
| <=  | Меньше или равно |
| == | Равно |
| 1= | Не равно |

В Python любое число, не равное нулю, или непустой объект интерпретируется как
истина

Числа, равные нулю, пустые объекты и специальный объект None интерпретируются
как ложь
```
>>> '' and '3' # False and True
''
>>> '' or '3' # False or True
'3'
>>>
```

У Python есть три логических оператора and, or, not

Результатом применения логического оператора not (НЕ) произойдет отрицание
операнда, т.е. если операнд истинный, то not вернет – ложь, если ложный, то – истину
```
>>> x = 6 > 7
>>> x
False
>>> not x
True
>>> not None
True
>>> not 2
False
>>>
```
Логический оператор and (И) вернет True (истину) или False (ложь), если его операндами являются логические высказывания
```
>>> 2 > 5 and 4 > 1 # комбинация False and (И) True вернет False
False
```
Если операндами оператора and являются объекты, то в результате Python вернет объект
```
>>> '' and 4 # False and True
''
```
Для вычисления оператора and Python вычисляет операнды слева направо и возвращает
первый объект, имеющий ложное значение
```
>>> 0 and 2 # вернет первый ложный объект-операнд
0
>>> 5 and 4 вернет крайний правый объект-операнд
4
```
Если Python не удается найти ложный объект-операнд, то он возвращает крайний правый операнд

Логический оператор or действует похожим образом, но для объектов-операндов Python возвращает первый объект, имеющий истинное значение. Python прекратит дальнейшие вычисления, как только будет найден первый объект, имеющий истинное значение
```
>>> 0 or 3 # вернет первый истинный объект-операнд
3
>>> None or 6 # вернет второй объект-операнд, т.к. первый всегда ложный
6
>>> None or 0 # вернет оставшийся объект-операнд
0
>>>
```

Логические выражения можно комбинировать
```
>>> 1+(3+7) # приоритет + выше, чем >
11
>>> 1+(3>7) # скобки способствуют наглядности и избавляют от ошибок
1
>>> 1 + False
1
>>> 1 + True
2
```
В Python можно проверять принадлежность интервалу
```
>>> x = 1
>>> -1 < x < 4 # эквивалентно: x > -1 and x < 14
True
>>>
```
Можно сравнить строки

Определить какое число соответсвует символу можно с помощью функции  ord()
```
>>> ord('F')
70
```
```
>>> 'B' > 'b'
False
```
Для сравнения строк Python их сравнивает посимвольно
```
>>> 'Aaaaa' < 'AAaaa'
False
```
Оператор _in_ проверяет наличие подстроки в строке
```
>>> 'a' in 'abc'
True
>>> 'A' in 'abc' # большой буквы А нет
False
>>> '' in 'abc' # пустая строка есть в любой строке
True
>>> '' in ''
True
```

### If

```
if  <<условие>>:        # блок выражений выполняется только в том случае, если выражение, которое находится в условии, является истинным
  <<блок выражения>>
elif  <<условие>>:
  <<блок выражения>>
else:                   #  выполняется, когда все вышестоящие условия вернули False.
  <<блок выражения>>
```

### Модули

Импорт модуля
```
import math
```
Обращение к функции модуля
```
math.sqrt(16)
```
Документация
```
help(math) # всего модуля
help(math.sqrt) № отельной функции
```
В момент импортирования модуля math создается переменная с именем math
```
>>> type(math)
<class 'module'>
```
Функция type() показала, что тип данных переменной math – модуль.
Переменная math содержит ссылку (адрес) модульного объекта. В этом объекте
содержатся ссылки на функции (функциональные объекты)

Функция type() показала, что тип данных переменной math – модуль.
Переменная math содержит ссылку (адрес) модульного объекта. В этом объекте
содержатся ссылки на функции (функциональные объекты)

В Python можно импортировать отдельную функцию из модуля

```
>>> from math import sqrt
>>> sqrt(9)
3.0
```
Таким образом, Python не будет создавать переменную math, а загрузит в память только
функцию sqrt(). Теперь вызов функции можно производить, не обращаясь к имени
модуля math

При импортировании одноименной функции (from math import sqrt), она заменит функцию из нашего кода. Если импортировать весь модуль (import math), то такой проблемы не будет.

Некоторые модули импортируются автоматически в момент начала работы, например __builtins__

Места хранения модулей по умолчанию
```
import sys
sys.path
```
В целях экономии ресурсов, повторное импортирование не приводит к выполнению модуля, т.е.
он повторно не импортируется.

Чтобы импортировать повторно:
```
>>> import imp
>>> imp.reload(modulname)
```
Чтобы отделить исполнение модуля от ипортировния используется специальная переменная ____name____ (по два нижних подчеркивания). Если мы запускаем модуль, то содержимое переменной ____name____ будет равно строке ____name____, а в случае импортирования – переменная ____name____ будет содержать имя модуля
```
def sum(a,b):
    return a+b

if __name__ == "__name__": # выполниться только при выполнении модуля
    a = int(input("Введите число: "))
    b = int(input("Введите ещё одно число: "))
    print(sum(a,b))
```

### Тестирование

#### Автоматизированное тестирование функций

Если рузультат вызова функции совпадает с описанием, то на экране ничего не появится
```
def func(a,b):
    """
    >>> func(2,4)
    6             # ожидаемый рузултат
    """
    return a+b

import doctest
doctest.testmod()
```
### Строковые методы

Тип данных является классом
```
>>> type(0)
<class 'int'>
```

Рассмотрим пример вызова строкового метода (полная форма)
```
>>> str.capitalize('hello')
'Hello'
```
Обычно используется сокращенная форма
```
>>> 'hello'.capitalize()
'Hello'
```
В момент, когда мы используем сокращенную форму для вызова метода, Python
преобразует ее в полную форму, а затем вызывает

Для вызова справки у методов необходимо через точку указывать их класс
```
help(str.capitalize)
```
#### Примеры

```
>>> ('TTA' + 'G'*3).count('T')
2
```
```
>>> '{0} и {1}'.format('труд', 'май')
'труд и май'
```
Формат вывода метода format() может варьироваться:
```
>>> n = 10
>>> '{:b}'.format(n) # вывод в двоичной системе счисления
'1010'
>>> '{:c}'.format(n) # вывод в формате Unicode
'\n'
>>> '{:d}'.format(n) # по снованию 10
'10'
>>> '{:x}'.format(n) # по основанию 16
'a'
```
В Python есть полезные строковые методы, которые возвращают (True) истину или (False) ложь:
```
>>> 'spec'.startswith('a')
False
```
При работе с текстами полезно использовать строковый метод strip():
```
>>> s = '         \n ssssss'
\n'
>>> s.strip()
'ssssss'
```
Метод swapcase() возвращает строку с противоположными регистрами символов:
```
>>> 'Hello'.swapcase()
'hELLO'
```
Python позволяет творить чудеса с вызовами методов – их можно вызывать подряд в одну строку:
```
>>> 'ПРИВЕТ'.swapcase().endswith('т')
True
```
Перечень популярных строковых методов
```
s.upper() – возвращает строку в верхнем регистре
s.lower() – возвращает строку в нижнем регистре
s.title() – возвращает строку, первый символ которой в верхнем регистре
s.find('вет', 2, 3) – возвращает позицию подстроки в интервале либо -1
s.count('e', 1, 5) – возвращает количество подстрок в интервале либо -1
s.isalpha() – проверяет, состоит ли строка только из букв
s.isdigit() – проверяет, состоит ли строка только из чисел
s.isupper() – проверяет, написаны ли все символы в верхнем регистре
s.islower() – проверяет, написаны ли все символы в нижнем регистре
s.istitle() – проверяет, начинается ли строка с большой буквы
s.isspace() – проверяет, состоит ли строка только из пробелов
```
Объеденение строчек
```
>>> 'TT' + 'rr'
'TTrr'
```
На самом деле, в этот момент Python вызывает специальный строковый метод ____add____() и передает ему в качестве первого аргумента строку 'rr':
```
>>> 'TT'.__add__('rr')
'TTrr'
```
Напомню, что этот вызов затем преобразуется Python в полную форму (результат будет аналогичный):
```
>>> str.__add__("TT", 'rr')
'TTrr'
```

### Списки

#### Операции над списками

Обращаnmся к элементам списка можно по индексу. Обращение по несуществующему индексу вызовет ошибку
```
>>> e = [12, 345, 65, 72]
>>> e[0]
12
>>> e[-1] # последний элемент
72
```

Списки можно изменять в отличие от строки
```
>>> e = [12, 345, 65, 72]
>>> e[1] = 421
>>> e
[12, 421, 65, 72]
```

Функции списков

```
len(L) – возвращает число элементов в списке L
max(L) – возвращает максимальное значение в списке L
min(L) – возвращает минимальное значение в списке L
sum(L) – возвращает сумму значений в списке L
sorted(L) – возвращает копию списка L, в котором элементы упорядочены
по возрастанию. Не изменяет список L
```

Операция сложения, умножения и удаления
```
>>> s = [23, 14, 51]
>>> t = s + [4] # сложение
>>> t
[23, 14, 51, 4]
>>> t = t * 2 # умножение
>>> t
[23, 14, 51, 4, 23, 14, 51, 4]
>>> del t[1] # удаление
>>> t
[23, 51, 4, 23, 14, 51, 4]
```

Опеартор _in_
```
e = [12, 32, 62]
if 32 in e:
    print ('Значение есть в списке')

```

Операции взятия среза и удаления
```
>>> t = [21, 42, 21, 421]
>>> n = t[1:3] # срез
>>> n
[42, 21]
>>> del n[1:2] # удаление
>>> n
[42]
```

Срезы выполняются аналогично строкам

#### Псевдонимы и копирование списков

Важная особенность списков
```
>>> h = [23, 53, 15, 63]
>>> p = h        # содержат указатель на один и тот же список
>>> p
[23, 53, 15, 63]
>>> p[0] = 555   # модифицируем одну из переменных
>>> p
[555, 53, 15, 63]
>>> h            # изменилась другая переменная!
[555, 53, 15, 63]
```
В Python две переменные называются псевдонимами, когда они содержат одинаковые
адреса памяти

Проверка ссылаются ли переменные на один и тот же объект:
```
>>> x = y = [2, 4]
>>> x is y
True
>>> x = [2, 4]
>>> y = [2, 4]
>>> x is y
False
```

Есть два вида копирования списков: _поверхностное копирование_, при котором создается новый объект, но он будет заполнен ссылками на элементы, которые содержались в оригинале и _глубокое копирование_, котором создается
новый объект и рекурсивно создаются копии всех объектов, содержащихся в оригинале

Поверхностное
```
>>> a = [1,2,3,4]
>>> b = a
>>> b[1] = 7
>>> a
[1, 7, 3, 4]
```
Глубокое
```
>>> a = [1,2,3,4]
>>> import copy
>>> b  = copy.deepcopy(a)
>>> b[1] = 7
>>> a
[1, 2, 3, 4]
```
[Дополнительная информация](https://pythonworld.ru/moduli/modul-copy.html)

#### Методы списка

Примеры
```
>>> colors = ['red', 'orange', 'green']
>>> colors.extend(['black','blue']) # расширяет список списком
>>> colors
['red', 'orange', 'green', 'black', 'blue']
>>> colors.append('purple') # добавляет элемент в список
>>> colors
['red', 'orange', 'green', 'black', 'blue', 'purple']
>>> colors.insert(2,'yellow') # добавляет элемент в указанную позицию
>>> colors
['red', 'orange', 'yellow', 'green', 'black', 'blue', 'purple']
>>> colors.remove('black') # удаляет элемент из списка
>>> colors
['red', 'orange', 'yellow', 'green', 'blue', 'purple']
>>> colors.count('red') # считает количество повторений аргумента метода
1
>>> colors.index('green') # возвращает позицию в списке аргумента метода
3
```
Еще несколько полезных методов для списка
```
>>> colors
['red', 'orange', 'yellow', 'green', 'blue', 'purple']
>>> colors.pop() # удаляет и возвращает последний элемент списка
'purple'
>>> colors
['red', 'orange', 'yellow', 'green', 'blue']
>>> colors.reverse() # список в обратном порядке
>>> colors
['blue', 'green', 'yellow', 'orange', 'red']
>>> colors.sort() # сортирует список (вспомните о сравнении строк)
>>> colors
['blue', 'green', 'orange', 'red', 'yellow']
>>> colors.clear() # очищает список. Метод появился в версии 3.3. Аналог del color[:]
>>> colors
[]
```

#### Преобразование типов

Пеобразуем строки в список, измение списка, затем возврат его в строку
```
>>> s = 'это строка'
>>> list(s) # функция list() пытается преобразовать аргумент в список
['э', 'т', 'о', ' ', 'с', 'т', 'р', 'о', 'к', 'а']
>>> lst = list(s)
>>> lst[0] = 'Е' # изменяем список, полученный из строки
>>> lst
['Е', 'т', 'о', ' ', 'с', 'т', 'р', 'о', 'к', 'а']
>>> s = ''.join(lst) # преобразуем список в строку с помощью строкового метода join()
>>> s
'Ето строка'
````
Метод join() принимает на вход список, который необходимо преобразовать в строку, а
в качестве строкового объекта указывается соединитель элементов списка
```
>>> L = ['tra', 'ta', 'ta']
>>> ' '.join(L)
'tra ta ta'
```
Аналогично можно преобразовать число к списку (через строку) и затем изменить
полученный список
```
>>> n = 9987
>>> list(str(n))
['9', '9', '8', '7']
```
Если строка содержит разделитель, то ее можно преобразовать к списку с помощью
строкового метода split(), который по умолчанию в качестве разделителя использует
пробел
```
>>> s = 'da ad adadsasd adsasd'.split()
>>> s
['da', 'ad', 'adadsasd', 'adsasd']
```
Другой разделитель
```
>>> s = 's:f:g:h:e'.split(':')
>>> s
['s', 'f', 'g', 'h', 'e']
```

#### Вложенные списки
```
>>> lst = [['A', 1], ['B', 1], ['C', 3]]
>>> lst
[['A', 1], ['B', 1], ['C', 3]]
>>> lst[1]
['B', 1]
>>> lst[1][1] # обращение к вложенному списку
1
```

### Циклы

#### for

Цикл for позволяет перебрать все элементы указанного списка. Цикл сработает ровно
столько раз, сколько элементов находится в списке. Имя переменной, в которую на
каждом шаге будет помещаться элемент списка, выбирает программист.

```
>>> l = [12, 124, 5135, 12]
>>> for i in l:
>>>    print(i)
12
124
5135
12
```
Цикл for работает и для строк
```
>>> for i in 'hello':
>>>    print(i)
h
e
l
l
o
```
Цикл for позволяет не только выводить элементы строки или списка на экран, но и
производить над ними определенные операции
```
>>> l = [12, 124, 5135, 12]
>>> for i in l:
>>>     if i == 124:
>>>         print(i)
124
```
```
>>> word = 'Hello'
>>> for i in word:
>>>   if i.isupper():
>>>     print(i)
H
```

#### range

Функция range() создаёт последовательность (диапазон) чисел. В качестве аргументов функция принимает:
начальное значение диапазона (по умолчанию 0), конечное значение (не включительно) и
шаг (по умолчанию 1)
```
>>> for i in range(4):
>>>    print(i)
0
1
2
3
```
```
>>> for i in range(1, 7, 2):
>>>   print(i)
1
2
5
```
В обратном порядке
```
>>> for i in range(4, 1, -1):
>>>   print(i)
4
3
2
```
Вычислить сумму чисел в заданном диапазоне:
```
>>> t = 0
>>> for i in range(1,101):
>>>     t = t + i
>>> print(t)
5050
```
Альтернативный вариант
```
>>> sum(list(range(1, 101)))
5050
```
Диапазон, создаваемый функцией range(), часто используется для задания индексов.
Например, если необходимо изменить существующий список, умножив каждый его
элемент на 2:
```
lst = [4, 10, 5, -1.9]
>>> print(lst)
>>> for i in range(len(lst)):
>>>   lst[i]=lst[i] * 2
>>> print(lst)
[4, 10, 5, -1.9]
[8, 20, 10, -3.8]
```

#### Способы создания списков

С помощью строкового метода _append_
```
>>> lst = []
>>> for i in range(1,11):
>>>     lst.append(i)
>>> print(lst)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
С помощью диапозона

```
a = list(range(1,4))
print(a)
```
С помощью "дискогового влючения"

```
>>> a = [i for i in range(1,5)] # i - что делаем с элементом, второй i - что делаем с элементом, range - откуда берём.
>>> print(a)
[1, 2, 3, 4]
```

Пример использования
```
>>> a = [i*2 for i in range(1,10)]
>>> print(a)
[2, 4, 6, 8, 10, 12, 14, 16, 18]
```

Списковое включение позволяет задавать условие для выбора значения из диапазона
```
>>> a = [i*2 for i in range(1,10) if i != 5]
>>> print(a)
[2, 4, 6, 8, 12, 14, 16, 18]
```

Вместо диапазонов списковое включение позволяет указывать существующий список
```
>>> b = [1, 2, 3, 4]
>>> b = [i*2 for i in b]
>>> print(b)
[2, 4, 6, 8]
```

По аналогии можно перебирать символы из строки и формировать из них список
```
>>> a = [i*2 for i in 'asf']
>>> print(a)
['aa', 'ss', 'ff']
```
В Python есть интересная функция map(), которая позволяет создавать новый список на
основе существующего списка
```
>>> def func(x):
>>>     return x + 3
>>> b = list(map(func,[1,2,3])) # в качестве второго аргумента может принимать строку. Результат работы
функции добавляется как элемент нового списка
>>> print(b)
[4, 5, 6]
```
Получить результат вызова функцииmap() можно через цикл for или функцию list().
Функции, которые принимают на вход другие функции, называются _функциями высшего порядка_

Пример вызова для строки
```
>>> def func(s):
>>>     return s * 3
>>> b = list(map(func,'hello'))
>>> print(b)
['hhh', 'eee', 'lll', 'lll', 'ooo']
```

Получить список, состоящий из случайных целых чисел
```
>>> from random import randint
>>> a = [(randint(1,5)) for i in range(5)]
>>> print(a)
[3, 5, 1, 4, 1]
```
Ручной ввод значений для списка
```
>>> a = []
>>> n = int(input()) # количество элементов в списке
>>> for i in range(n):
>>>     new_alement = int(input()) # считывание очередного элемента
>>>     a.append(new_alement) # добавление его в список
>>>     # a.append(int(input()) # вместо двух последних строчек
>>> print(a)
3
2
3
1
[2, 3, 1]
```
Решение этой же задачи через списковое влючение:
```
A = [int(input()) for i in range(int(input()))]
```
#### while



### Заметки

#### Философия Python

```
import this
````

#### Нижнее подчеркивание

Нижнее подчеркивание вызывает последний полученный результат
```
>>> 7*8
56
>>> _ + 4
60
>>>
```
#### Модуль keyword

Вызвать список ключевых слов
```
import keyword
keyword.kwlist
# keyword.iskeyword(строка) - проверка строки
```
#### id

Идентификатор объекта
```
id(var)
```
Python ссылается на уже существующие объекты в памяти, если объект имеет целое и небольшое значение

#### Ссылки на об объект

Текущее количество ссылок на объект можно узнать с помощью функции sys.getrefcount()
```
import sys
sys.getrefcount()
```
#### pass

Ессли функция ничего не делает, то указывается ключевое слово _pass_
```
def func():
  pass
```
#### dir

Возвращает имена [переменных], доступные в локальной области, либо атрибуты указанного объекта в алфавитном порядке.

```
dir(object)
```

#### Документирование кода

Для добавления описания собственных функции перед телом функции помещается информация в """ тройные двойные кавычки
```
def func():
  """
  Это описание
  функции
  """

>>> help(func)
```

[Рекомендации по документированию PEP 257](https://www.python.org/dev/peps/pep-0257/)
